#include <unittest++/UnitTest++.h>
#include <armadillo>
#include <iostream>

#include "integrator.h"
#include "stimuli/grating.h"

using namespace std;
using namespace arma;


SUITE(INTEGRATOR){

    TEST(grating_0){
        int ns = 2;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1){
        int ns = 2;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_2){
        int ns = 2;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_3){
        int ns = 2;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_4){
        int ns = 2;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_5){
        int ns = 2;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_6){
        int ns = 2;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_7){
        int ns = 2;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_8){
        int ns = 2;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_9){
        int ns = 2;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_10){
        int ns = 2;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_11){
        int ns = 2;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_12){
        int ns = 2;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_13){
        int ns = 2;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_14){
        int ns = 2;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_15){
        int ns = 2;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_16){
        int ns = 2;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_17){
        int ns = 2;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_18){
        int ns = 2;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_19){
        int ns = 2;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_20){
        int ns = 2;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_21){
        int ns = 2;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_22){
        int ns = 2;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_23){
        int ns = 2;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_24){
        int ns = 2;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_25){
        int ns = 2;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_26){
        int ns = 2;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_27){
        int ns = 2;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_28){
        int ns = 2;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_29){
        int ns = 2;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_30){
        int ns = 2;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_31){
        int ns = 2;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_32){
        int ns = 2;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_33){
        int ns = 2;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_34){
        int ns = 2;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_35){
        int ns = 2;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_36){
        int ns = 2;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_37){
        int ns = 2;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_38){
        int ns = 2;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_39){
        int ns = 2;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_40){
        int ns = 2;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_41){
        int ns = 2;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_42){
        int ns = 2;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_43){
        int ns = 2;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_44){
        int ns = 2;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_45){
        int ns = 2;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_46){
        int ns = 2;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_47){
        int ns = 2;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_48){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_49){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_50){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_51){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_52){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_53){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_54){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_55){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_56){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_57){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_58){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_59){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_60){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_61){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_62){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_63){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_64){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_65){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_66){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_67){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_68){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_69){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_70){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_71){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_72){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_73){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_74){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_75){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_76){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_77){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_78){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_79){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_80){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_81){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_82){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_83){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_84){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_85){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_86){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_87){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_88){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_89){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_90){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_91){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_92){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_93){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_94){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_95){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_96){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_97){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_98){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_99){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_100){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_101){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_102){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_103){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_104){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_105){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_106){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_107){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_108){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_109){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_110){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_111){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_112){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_113){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_114){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_115){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_116){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_117){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_118){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_119){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_120){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_121){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_122){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_123){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_124){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_125){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_126){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_127){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_128){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_129){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_130){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_131){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_132){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_133){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_134){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_135){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_136){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_137){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_138){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_139){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_140){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_141){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_142){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_143){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_144){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_145){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_146){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_147){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_148){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_149){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_150){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_151){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_152){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_153){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_154){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_155){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_156){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_157){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_158){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_159){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_160){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_161){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_162){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_163){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_164){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_165){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_166){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_167){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_168){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_169){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_170){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_171){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_172){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_173){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_174){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_175){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_176){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_177){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_178){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_179){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_180){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_181){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_182){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_183){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_184){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_185){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_186){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_187){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_188){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_189){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_190){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_191){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_192){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_193){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_194){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_195){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_196){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_197){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_198){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_199){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_200){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_201){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_202){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_203){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_204){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_205){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_206){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_207){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_208){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_209){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_210){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_211){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_212){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_213){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_214){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_215){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_216){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_217){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_218){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_219){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_220){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_221){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_222){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_223){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_224){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_225){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_226){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_227){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_228){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_229){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_230){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_231){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_232){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_233){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_234){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_235){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_236){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_237){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_238){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_239){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_240){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_241){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_242){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_243){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_244){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_245){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_246){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_247){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_248){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_249){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_250){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_251){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_252){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_253){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_254){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_255){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_256){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_257){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_258){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_259){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_260){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_261){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_262){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_263){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_264){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_265){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_266){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_267){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_268){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_269){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_270){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_271){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_272){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_273){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_274){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_275){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_276){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_277){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_278){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_279){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_280){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_281){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_282){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_283){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_284){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_285){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_286){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_287){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_288){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_289){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_290){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_291){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_292){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_293){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_294){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_295){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_296){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_297){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_298){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_299){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_300){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_301){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_302){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_303){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_304){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_305){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_306){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_307){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_308){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_309){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_310){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_311){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_312){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_313){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_314){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_315){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_316){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_317){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_318){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_319){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_320){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_321){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_322){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_323){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_324){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_325){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_326){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_327){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_328){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_329){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_330){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_331){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_332){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_333){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_334){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_335){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_336){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_337){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_338){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_339){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_340){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_341){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_342){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_343){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_344){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_345){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_346){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_347){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_348){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_349){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_350){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_351){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_352){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_353){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_354){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_355){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_356){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_357){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_358){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_359){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_360){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_361){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_362){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_363){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_364){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_365){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_366){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_367){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_368){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_369){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_370){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_371){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_372){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_373){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_374){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_375){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_376){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_377){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_378){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_379){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_380){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_381){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_382){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_383){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_384){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_385){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_386){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_387){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_388){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_389){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_390){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_391){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_392){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_393){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_394){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_395){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_396){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_397){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_398){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_399){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_400){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_401){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_402){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_403){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_404){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_405){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_406){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_407){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_408){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_409){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_410){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_411){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_412){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_413){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_414){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_415){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_416){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_417){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_418){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_419){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_420){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_421){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_422){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_423){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_424){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_425){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_426){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_427){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_428){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_429){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_430){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_431){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_432){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_433){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_434){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_435){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_436){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_437){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_438){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_439){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_440){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_441){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_442){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_443){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_444){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_445){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_446){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_447){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_448){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_449){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_450){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_451){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_452){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_453){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_454){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_455){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_456){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_457){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_458){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_459){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_460){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_461){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_462){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_463){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_464){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_465){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_466){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_467){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_468){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_469){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_470){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_471){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_472){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_473){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_474){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_475){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_476){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_477){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_478){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_479){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_480){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_481){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_482){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_483){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_484){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_485){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_486){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_487){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_488){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_489){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_490){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_491){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_492){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_493){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_494){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_495){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_496){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_497){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_498){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_499){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_500){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_501){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_502){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_503){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_504){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_505){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_506){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_507){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_508){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_509){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_510){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_511){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_512){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_513){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_514){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_515){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_516){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_517){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_518){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_519){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_520){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_521){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_522){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_523){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_524){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_525){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_526){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_527){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_528){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_529){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_530){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_531){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_532){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_533){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_534){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_535){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_536){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_537){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_538){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_539){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_540){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_541){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_542){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_543){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_544){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_545){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_546){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_547){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_548){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_549){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_550){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_551){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_552){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_553){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_554){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_555){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_556){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_557){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_558){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_559){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_560){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_561){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_562){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_563){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_564){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_565){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_566){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_567){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_568){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_569){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_570){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_571){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_572){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_573){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_574){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_575){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_576){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_577){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_578){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_579){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_580){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_581){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_582){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_583){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_584){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_585){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_586){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_587){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_588){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_589){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_590){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_591){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_592){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_593){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_594){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_595){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_596){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_597){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_598){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_599){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_600){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_601){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_602){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_603){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_604){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_605){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_606){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_607){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_608){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_609){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_610){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_611){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_612){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_613){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_614){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_615){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_616){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_617){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_618){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_619){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_620){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_621){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_622){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_623){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_624){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_625){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_626){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_627){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_628){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_629){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_630){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_631){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_632){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_633){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_634){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_635){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_636){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_637){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_638){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_639){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_640){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_641){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_642){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_643){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_644){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_645){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_646){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_647){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_648){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_649){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_650){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_651){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_652){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_653){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_654){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_655){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_656){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_657){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_658){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_659){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_660){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_661){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_662){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_663){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_664){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_665){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_666){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_667){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_668){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_669){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_670){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_671){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_672){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_673){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_674){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_675){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_676){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_677){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_678){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_679){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_680){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_681){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_682){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_683){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_684){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_685){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_686){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_687){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_688){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_689){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_690){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_691){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_692){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_693){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_694){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_695){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_696){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_697){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_698){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_699){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_700){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_701){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_702){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_703){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_704){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_705){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_706){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_707){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_708){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_709){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_710){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_711){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_712){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_713){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_714){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_715){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_716){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_717){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_718){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_719){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_720){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_721){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_722){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_723){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_724){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_725){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_726){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_727){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_728){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_729){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_730){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_731){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_732){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_733){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_734){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_735){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_736){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_737){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_738){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_739){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_740){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_741){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_742){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_743){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_744){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_745){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_746){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_747){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_748){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_749){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_750){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_751){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_752){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_753){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_754){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_755){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_756){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_757){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_758){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_759){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_760){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_761){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_762){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_763){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_764){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_765){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_766){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_767){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_768){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_769){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_770){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_771){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_772){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_773){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_774){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_775){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_776){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_777){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_778){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_779){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_780){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_781){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_782){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_783){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_784){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_785){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_786){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_787){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_788){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_789){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_790){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_791){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_792){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_793){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_794){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_795){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_796){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_797){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_798){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_799){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_800){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_801){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_802){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_803){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_804){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_805){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_806){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_807){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_808){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_809){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_810){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_811){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_812){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_813){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_814){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_815){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_816){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_817){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_818){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_819){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_820){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_821){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_822){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_823){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_824){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_825){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_826){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_827){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_828){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_829){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_830){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_831){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_832){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_833){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_834){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_835){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_836){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_837){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_838){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_839){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_840){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_841){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_842){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_843){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_844){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_845){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_846){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_847){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_848){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_849){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_850){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_851){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_852){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_853){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_854){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_855){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_856){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_857){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_858){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_859){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_860){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_861){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_862){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_863){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_864){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_865){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_866){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_867){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_868){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_869){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_870){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_871){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_872){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_873){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_874){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_875){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_876){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_877){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_878){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_879){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_880){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_881){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_882){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_883){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_884){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_885){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_886){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_887){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_888){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_889){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_890){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_891){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_892){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_893){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_894){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_895){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_896){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_897){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_898){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_899){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_900){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_901){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_902){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_903){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_904){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_905){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_906){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_907){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_908){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_909){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_910){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_911){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_912){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_913){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_914){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_915){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_916){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_917){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_918){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_919){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_920){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_921){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_922){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_923){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_924){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_925){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_926){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_927){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_928){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_929){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_930){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_931){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_932){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_933){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_934){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_935){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_936){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_937){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_938){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_939){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_940){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_941){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_942){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_943){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_944){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_945){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_946){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_947){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_948){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_949){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_950){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_951){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_952){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_953){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_954){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_955){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_956){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_957){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_958){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_959){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_960){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_961){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_962){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_963){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_964){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_965){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_966){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_967){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_968){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_969){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_970){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_971){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_972){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_973){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_974){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_975){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_976){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_977){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_978){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_979){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_980){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_981){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_982){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_983){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_984){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_985){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_986){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_987){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_988){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_989){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_990){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_991){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_992){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_993){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_994){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_995){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_996){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_997){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_998){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_999){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1000){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1001){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1002){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1003){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1004){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1005){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1006){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1007){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1008){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1009){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1010){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1011){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1012){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1013){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1014){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1015){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1016){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1017){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1018){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1019){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1020){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1021){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1022){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1023){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1024){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1025){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1026){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1027){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1028){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1029){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1030){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1031){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1032){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1033){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1034){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1035){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1036){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1037){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1038){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1039){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1040){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1041){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1042){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1043){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1044){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1045){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1046){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(1);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1047){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(1);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1048){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1049){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1050){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1051){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1052){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1053){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1054){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1055){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1056){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1057){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1058){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1059){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1060){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1061){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1062){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1063){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1064){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1065){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1066){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1067){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1068){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1069){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1070){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1071){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1072){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1073){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1074){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1075){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1076){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1077){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1078){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1079){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1080){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1081){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1082){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1083){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1084){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1085){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1086){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1087){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1088){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1089){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1090){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1091){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1092){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1093){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1094){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1095){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1096){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(2);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1097){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(2);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1098){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1099){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1100){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1101){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1102){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1103){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1104){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1105){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1106){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1107){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1108){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1109){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1110){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1111){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1112){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1113){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1114){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1115){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1116){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1117){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1118){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1119){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1120){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1121){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1122){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1123){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1124){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1125){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1126){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1127){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1128){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1129){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1130){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1131){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1132){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1133){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1134){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1135){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1136){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1137){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1138){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1139){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1140){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1141){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1142){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1143){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1144){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1145){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1146){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(3);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1147){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(3);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1148){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1149){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1150){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1151){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1152){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1153){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1154){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1155){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1156){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1157){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1158){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1159){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1160){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1161){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1162){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1163){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1164){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1165){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1166){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1167){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1168){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1169){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1170){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1171){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1172){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1173){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1174){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1175){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1176){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1177){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1178){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1179){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1180){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1181){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1182){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1183){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1184){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1185){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1186){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1187){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1188){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1189){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1190){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1191){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1192){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1193){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1194){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1195){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1196){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(4);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1197){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(4);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1198){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1199){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(1);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1200){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1201){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(1);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1202){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1203){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(1);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1204){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1205){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(1);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1206){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1207){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(1);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1208){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1209){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(2);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1210){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1211){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(2);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1212){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1213){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(2);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1214){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1215){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(2);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1216){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1217){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(2);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1218){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1219){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(3);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1220){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1221){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(3);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1222){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1223){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(3);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1224){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1225){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(3);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1226){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1227){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(3);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1228){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1229){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(4);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1230){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1231){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(4);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1232){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1233){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(4);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1234){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1235){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(4);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1236){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1237){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(4);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1238){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1239){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(5);
        double ky = k(1);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1240){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1241){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(5);
        double ky = k(2);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1242){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1243){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(5);
        double ky = k(3);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1244){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1245){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(5);
        double ky = k(4);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1246){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =-0.1;
        double wd = w(5);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }
    TEST(grating_1247){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double C =2.2;
        double wd = w(5);
        double kx = k(5);
        double ky = k(5);

        Grating S(&integrator, {kx, ky}, wd, C);
        //Spatiotemporal signal
        S.computeSpatiotemporal();
        g.set_real(S.spatioTemporal());
        //fourier signal

        S.computeFourierTransform();
        f = S.fourierTransform();
        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-10);
                }
            }
        }
    }







}


