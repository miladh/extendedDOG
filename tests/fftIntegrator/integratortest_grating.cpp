#include <unittest++/UnitTest++.h>
#include <armadillo>
#include <iostream>

#include "integrator.h"
#include "stimuli/grating.h"

using namespace std;
using namespace arma;


SUITE(INTEGRATOR){



    TEST(grating_0){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_4){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_5){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_6){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_7){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_8){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_9){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_10){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_11){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_12){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_13){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_14){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_15){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_16){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_17){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_18){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_19){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_20){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_21){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_22){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_23){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_24){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_25){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_26){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_27){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_28){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_29){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_30){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_31){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_32){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_33){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_34){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_35){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_36){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_37){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_38){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_39){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_40){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_41){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_42){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_43){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_44){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_45){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_46){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_47){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_48){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_49){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_50){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_51){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_52){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_53){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_54){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_55){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_56){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_57){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_58){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_59){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_60){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_61){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_62){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_63){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_64){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_65){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_66){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_67){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_68){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_69){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_70){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_71){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_72){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_73){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_74){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_75){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_76){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_77){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_78){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_79){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_80){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_81){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_82){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_83){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_84){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_85){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_86){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_87){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_88){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_89){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_90){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_91){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_92){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_93){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_94){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_95){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_96){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_97){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_98){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_99){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_100){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_101){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_102){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_103){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_104){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_105){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_106){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_107){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_108){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_109){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_110){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_111){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_112){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_113){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_114){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_115){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_116){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_117){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_118){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_119){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_120){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_121){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_122){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_123){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_124){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_125){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_126){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_127){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_128){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_129){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_130){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_131){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_132){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_133){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_134){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_135){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_136){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_137){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_138){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_139){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_140){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_141){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_142){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_143){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_144){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_145){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_146){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_147){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_148){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_149){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_150){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_151){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_152){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_153){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_154){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_155){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_156){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_157){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_158){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_159){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_160){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_161){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_162){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_163){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_164){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_165){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_166){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_167){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_168){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_169){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_170){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_171){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_172){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_173){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_174){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_175){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_176){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_177){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_178){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_179){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_180){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_181){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_182){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_183){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_184){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_185){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_186){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_187){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_188){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_189){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_190){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_191){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_192){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_193){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_194){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_195){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_196){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_197){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_198){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_199){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_200){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_201){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_202){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_203){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_204){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_205){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_206){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_207){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_208){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_209){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_210){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_211){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_212){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_213){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_214){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_215){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_216){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_217){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_218){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_219){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_220){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_221){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_222){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_223){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_224){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_225){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_226){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_227){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_228){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_229){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_230){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_231){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_232){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_233){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_234){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_235){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_236){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_237){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_238){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_239){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_240){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_241){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_242){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_243){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_244){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_245){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_246){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_247){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_248){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_249){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_250){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_251){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_252){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_253){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_254){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_255){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_256){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_257){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_258){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_259){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_260){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_261){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_262){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_263){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_264){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_265){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_266){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_267){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_268){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_269){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_270){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_271){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_272){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_273){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_274){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_275){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_276){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_277){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_278){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_279){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_280){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_281){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_282){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_283){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_284){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_285){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_286){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_287){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_288){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_289){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_290){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_291){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_292){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_293){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_294){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_295){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_296){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_297){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_298){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_299){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_300){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_301){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_302){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_303){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_304){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_305){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_306){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_307){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_308){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_309){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_310){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_311){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_312){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_313){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_314){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_315){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_316){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_317){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_318){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_319){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_320){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_321){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_322){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_323){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_324){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_325){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_326){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_327){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_328){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_329){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_330){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_331){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_332){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_333){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_334){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_335){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_336){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_337){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_338){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_339){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_340){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_341){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_342){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_343){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_344){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_345){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_346){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_347){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_348){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_349){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_350){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_351){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_352){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_353){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_354){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_355){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_356){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_357){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_358){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_359){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_360){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_361){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_362){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_363){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_364){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_365){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_366){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_367){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_368){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_369){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_370){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_371){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_372){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_373){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_374){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_375){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_376){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_377){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_378){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_379){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_380){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_381){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_382){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_383){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_384){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_385){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_386){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_387){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_388){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_389){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_390){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_391){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_392){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_393){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_394){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_395){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_396){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_397){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_398){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_399){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_400){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_401){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_402){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_403){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_404){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_405){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_406){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_407){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_408){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_409){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_410){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_411){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_412){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_413){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_414){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_415){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_416){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_417){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_418){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_419){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_420){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_421){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_422){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_423){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_424){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_425){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_426){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_427){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_428){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_429){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_430){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_431){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_432){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_433){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_434){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_435){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_436){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_437){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_438){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_439){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_440){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_441){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_442){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_443){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_444){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_445){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_446){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_447){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_448){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_449){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_450){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_451){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_452){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_453){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_454){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_455){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_456){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_457){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_458){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_459){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_460){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_461){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_462){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_463){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_464){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_465){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_466){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_467){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_468){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_469){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_470){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_471){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_472){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_473){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_474){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_475){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_476){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_477){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_478){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_479){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_480){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_481){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_482){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_483){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_484){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_485){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_486){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_487){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_488){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_489){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_490){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_491){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_492){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_493){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_494){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_495){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_496){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_497){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_498){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_499){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_500){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_501){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_502){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_503){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_504){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_505){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_506){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_507){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_508){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_509){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_510){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_511){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_512){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_513){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_514){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_515){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_516){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_517){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_518){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_519){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_520){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_521){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_522){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_523){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_524){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_525){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_526){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_527){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_528){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_529){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_530){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_531){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_532){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_533){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_534){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_535){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_536){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_537){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_538){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_539){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_540){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_541){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_542){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_543){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_544){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_545){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_546){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_547){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_548){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_549){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_550){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_551){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_552){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_553){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_554){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_555){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_556){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_557){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_558){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_559){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_560){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_561){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_562){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_563){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_564){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_565){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_566){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_567){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_568){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_569){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_570){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_571){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_572){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_573){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_574){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_575){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_576){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_577){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_578){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_579){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_580){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_581){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_582){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_583){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_584){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_585){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_586){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_587){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_588){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_589){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_590){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_591){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_592){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_593){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_594){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_595){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_596){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_597){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_598){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_599){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_600){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_601){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_602){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_603){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_604){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_605){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_606){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_607){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_608){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_609){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_610){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_611){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_612){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_613){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_614){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_615){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_616){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_617){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_618){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_619){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_620){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_621){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_622){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_623){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_624){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_625){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_626){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_627){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_628){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_629){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_630){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_631){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_632){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_633){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_634){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_635){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_636){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_637){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_638){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_639){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_640){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_641){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_642){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_643){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_644){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_645){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_646){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_647){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_648){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_649){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_650){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_651){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_652){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_653){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_654){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_655){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_656){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_657){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_658){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_659){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_660){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_661){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_662){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_663){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_664){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_665){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_666){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_667){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_668){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_669){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_670){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_671){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_672){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_673){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_674){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_675){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_676){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_677){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_678){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_679){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_680){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_681){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_682){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_683){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_684){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_685){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_686){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_687){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_688){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_689){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_690){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_691){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_692){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_693){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_694){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_695){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_696){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_697){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_698){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_699){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_700){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_701){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_702){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_703){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_704){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_705){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_706){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_707){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_708){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_709){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_710){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_711){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_712){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_713){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_714){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_715){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_716){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_717){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_718){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_719){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_720){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_721){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_722){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_723){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_724){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_725){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_726){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_727){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_728){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_729){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_730){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_731){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_732){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_733){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_734){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_735){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_736){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_737){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_738){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_739){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_740){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_741){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_742){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_743){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_744){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_745){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_746){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_747){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_748){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_749){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_750){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_751){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_752){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_753){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_754){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_755){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_756){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_757){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_758){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_759){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_760){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_761){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_762){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_763){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_764){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_765){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_766){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_767){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_768){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_769){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_770){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_771){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_772){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_773){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_774){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_775){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_776){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_777){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_778){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_779){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_780){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_781){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_782){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_783){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_784){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_785){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_786){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_787){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_788){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_789){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_790){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_791){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_792){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_793){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_794){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_795){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_796){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_797){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_798){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_799){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_800){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_801){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_802){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_803){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_804){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_805){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_806){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_807){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_808){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_809){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_810){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_811){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_812){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_813){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_814){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_815){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_816){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_817){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_818){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_819){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_820){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_821){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_822){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_823){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_824){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_825){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_826){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_827){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_828){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_829){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_830){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_831){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_832){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_833){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_834){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_835){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_836){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_837){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_838){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_839){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_840){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_841){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_842){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_843){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_844){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_845){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_846){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_847){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_848){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_849){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_850){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_851){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_852){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_853){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_854){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_855){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_856){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_857){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_858){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_859){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_860){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_861){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_862){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_863){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_864){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_865){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_866){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_867){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_868){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_869){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_870){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_871){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_872){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_873){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_874){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_875){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_876){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_877){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_878){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_879){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_880){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_881){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_882){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_883){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_884){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_885){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_886){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_887){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_888){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_889){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_890){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_891){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_892){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_893){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_894){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_895){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_896){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_897){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_898){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_899){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_900){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_901){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_902){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_903){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_904){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_905){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_906){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_907){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_908){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_909){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_910){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_911){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_912){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_913){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_914){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_915){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_916){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_917){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_918){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_919){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_920){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_921){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_922){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_923){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_924){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_925){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_926){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_927){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_928){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_929){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_930){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_931){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_932){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_933){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_934){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_935){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_936){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_937){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_938){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_939){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_940){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_941){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_942){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_943){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_944){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_945){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_946){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_947){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_948){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_949){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_950){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_951){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_952){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_953){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_954){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_955){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_956){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_957){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_958){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_959){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_960){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_961){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_962){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_963){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_964){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_965){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_966){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_967){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_968){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_969){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_970){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_971){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_972){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_973){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_974){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_975){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_976){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_977){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_978){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_979){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_980){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_981){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_982){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_983){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_984){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_985){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_986){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_987){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_988){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_989){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_990){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_991){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_992){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_993){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_994){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_995){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_996){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_997){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_998){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_999){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1000){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1001){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1002){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1003){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1004){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1005){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1006){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1007){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1008){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1009){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1010){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1011){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1012){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1013){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1014){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1015){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1016){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1017){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1018){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1019){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1020){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1021){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1022){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1023){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1024){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1025){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1026){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1027){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1028){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1029){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1030){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1031){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1032){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1033){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1034){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1035){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1036){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1037){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1038){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1039){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1040){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1041){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1042){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1043){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1044){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1045){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1046){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1047){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1048){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1049){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1050){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1051){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1052){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1053){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1054){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1055){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1056){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1057){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1058){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1059){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1060){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1061){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1062){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1063){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1064){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1065){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1066){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1067){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1068){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1069){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1070){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1071){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1072){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1073){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1074){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1075){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1076){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1077){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1078){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1079){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1080){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1081){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1082){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1083){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1084){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1085){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1086){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1087){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1088){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1089){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1090){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1091){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1092){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1093){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1094){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1095){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1096){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1097){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1098){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1099){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1100){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1101){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1102){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1103){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1104){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1105){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1106){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1107){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1108){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1109){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1110){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1111){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1112){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1113){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1114){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1115){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1116){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1117){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1118){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1119){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1120){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1121){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1122){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1123){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1124){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1125){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1126){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1127){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1128){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1129){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1130){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1131){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1132){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1133){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1134){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1135){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1136){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1137){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1138){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1139){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1140){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1141){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1142){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1143){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1144){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1145){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1146){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1147){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1148){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1149){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1150){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1151){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1152){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1153){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1154){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1155){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1156){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1157){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1158){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1159){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1160){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1161){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1162){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1163){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1164){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1165){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1166){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1167){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1168){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1169){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1170){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1171){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1172){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1173){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1174){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1175){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1176){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1177){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1178){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1179){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1180){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1181){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1182){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1183){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1184){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1185){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1186){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1187){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1188){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1189){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1190){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1191){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1192){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1193){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1194){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1195){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1196){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1197){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1198){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1199){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1200){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1201){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1202){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1203){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1204){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1205){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1206){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1207){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1208){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1209){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1210){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1211){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1212){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1213){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1214){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1215){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1216){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1217){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1218){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1219){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1220){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1221){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1222){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1223){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1224){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1225){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1226){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1227){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1228){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1229){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1230){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1231){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1232){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1233){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1234){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1235){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1236){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1237){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1238){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1239){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1240){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1241){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1242){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1243){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1244){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1245){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1246){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1247){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1248){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1249){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1250){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1251){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1252){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1253){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1254){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1255){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1256){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1257){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1258){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1259){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1260){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1261){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1262){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1263){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1264){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1265){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1266){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1267){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1268){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1269){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1270){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1271){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1272){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1273){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1274){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1275){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1276){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1277){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1278){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1279){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1280){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1281){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1282){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1283){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1284){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1285){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1286){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1287){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1288){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1289){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1290){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1291){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1292){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1293){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1294){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1295){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1296){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1297){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1298){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1299){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1300){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1301){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1302){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1303){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1304){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1305){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1306){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1307){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1308){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1309){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1310){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1311){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1312){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1313){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1314){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1315){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1316){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1317){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1318){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1319){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1320){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1321){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1322){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1323){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1324){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1325){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1326){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1327){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1328){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1329){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1330){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1331){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1332){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1333){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1334){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1335){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1336){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1337){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1338){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1339){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1340){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1341){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1342){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1343){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1344){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1345){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1346){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1347){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1348){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1349){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1350){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1351){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1352){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1353){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1354){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1355){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1356){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1357){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1358){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1359){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1360){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1361){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1362){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1363){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1364){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1365){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1366){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1367){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1368){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1369){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1370){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1371){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1372){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1373){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1374){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1375){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1376){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1377){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1378){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1379){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1380){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1381){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1382){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1383){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1384){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1385){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1386){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1387){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1388){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1389){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1390){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1391){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1392){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1393){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1394){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1395){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1396){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1397){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1398){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1399){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1400){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1401){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1402){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1403){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1404){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1405){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1406){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1407){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1408){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1409){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1410){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1411){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1412){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1413){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1414){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1415){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1416){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1417){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1418){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1419){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1420){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1421){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1422){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1423){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1424){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1425){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1426){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1427){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1428){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1429){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1430){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1431){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1432){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1433){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1434){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1435){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1436){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1437){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1438){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1439){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1440){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1441){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1442){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1443){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1444){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1445){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1446){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1447){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1448){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1449){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1450){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1451){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1452){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1453){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1454){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1455){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1456){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1457){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1458){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1459){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1460){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1461){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1462){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1463){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1464){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1465){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1466){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1467){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1468){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1469){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1470){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1471){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1472){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1473){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1474){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1475){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1476){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1477){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1478){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1479){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1480){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1481){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1482){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1483){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1484){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1485){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1486){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1487){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1488){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1489){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1490){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1491){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1492){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1493){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1494){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1495){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1496){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1497){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1498){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1499){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1500){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1501){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1502){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1503){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1504){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1505){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1506){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1507){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1508){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1509){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1510){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1511){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1512){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1513){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1514){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1515){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1516){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1517){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1518){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1519){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1520){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1521){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1522){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1523){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1524){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1525){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1526){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1527){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1528){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1529){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1530){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1531){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1532){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1533){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1534){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1535){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1536){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1537){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1538){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1539){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1540){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1541){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1542){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1543){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1544){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1545){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1546){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1547){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1548){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1549){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1550){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1551){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1552){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1553){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1554){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1555){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1556){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1557){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1558){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1559){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1560){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1561){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1562){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1563){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1564){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1565){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1566){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1567){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1568){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1569){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1570){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1571){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1572){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1573){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1574){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1575){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1576){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1577){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1578){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1579){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1580){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1581){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1582){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1583){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1584){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1585){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1586){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1587){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1588){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1589){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1590){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1591){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1592){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1593){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1594){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1595){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1596){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1597){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1598){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1599){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1600){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1601){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1602){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1603){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1604){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1605){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1606){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1607){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1608){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1609){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1610){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1611){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1612){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1613){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1614){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1615){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1616){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1617){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1618){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1619){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1620){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1621){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1622){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1623){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1624){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1625){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1626){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1627){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1628){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1629){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1630){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1631){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1632){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1633){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1634){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1635){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1636){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1637){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1638){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1639){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1640){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1641){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1642){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1643){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1644){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1645){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1646){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1647){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1648){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1649){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1650){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1651){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1652){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1653){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1654){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1655){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1656){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1657){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1658){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1659){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1660){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1661){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1662){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1663){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1664){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1665){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1666){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1667){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1668){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1669){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1670){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1671){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1672){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1673){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1674){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1675){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1676){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1677){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1678){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1679){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1680){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1681){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1682){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1683){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1684){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1685){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1686){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1687){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1688){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1689){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1690){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1691){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1692){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1693){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1694){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1695){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1696){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1697){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1698){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1699){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1700){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1701){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1702){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1703){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1704){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1705){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1706){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1707){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1708){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1709){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1710){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1711){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1712){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1713){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1714){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1715){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1716){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1717){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1718){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1719){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1720){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1721){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1722){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1723){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1724){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1725){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1726){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1727){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1728){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1729){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1730){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1731){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1732){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1733){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1734){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1735){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1736){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1737){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1738){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1739){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1740){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1741){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1742){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1743){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1744){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1745){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1746){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1747){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1748){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1749){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1750){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1751){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1752){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1753){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1754){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1755){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1756){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1757){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1758){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1759){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1760){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1761){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1762){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1763){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1764){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1765){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1766){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1767){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1768){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1769){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1770){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1771){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1772){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1773){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1774){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1775){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1776){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1777){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1778){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1779){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1780){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1781){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1782){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1783){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1784){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1785){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1786){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1787){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1788){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1789){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1790){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1791){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1792){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1793){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1794){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1795){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1796){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1797){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1798){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1799){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1800){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1801){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1802){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1803){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1804){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1805){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1806){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1807){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1808){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1809){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1810){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1811){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1812){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1813){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1814){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1815){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1816){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1817){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1818){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1819){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1820){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1821){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1822){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1823){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1824){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1825){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1826){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1827){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1828){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1829){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1830){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1831){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1832){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1833){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1834){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1835){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1836){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1837){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1838){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1839){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1840){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1841){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1842){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1843){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1844){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1845){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1846){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1847){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1848){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1849){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1850){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1851){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1852){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1853){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1854){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1855){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1856){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1857){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1858){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1859){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1860){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1861){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1862){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1863){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1864){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1865){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1866){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1867){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1868){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1869){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1870){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1871){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1872){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1873){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1874){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1875){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1876){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1877){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1878){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1879){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1880){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1881){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1882){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1883){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1884){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1885){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1886){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1887){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1888){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1889){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1890){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1891){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1892){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1893){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1894){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1895){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1896){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1897){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1898){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1899){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1900){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1901){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1902){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1903){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1904){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1905){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1906){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1907){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1908){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1909){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1910){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1911){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1912){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1913){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1914){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1915){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1916){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1917){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1918){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1919){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1920){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1921){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1922){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1923){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1924){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1925){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1926){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1927){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1928){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1929){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1930){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1931){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1932){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1933){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1934){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1935){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1936){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1937){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1938){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1939){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1940){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1941){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1942){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1943){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1944){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1945){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1946){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1947){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1948){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1949){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1950){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1951){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1952){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1953){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1954){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1955){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1956){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1957){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1958){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1959){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1960){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1961){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1962){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1963){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1964){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1965){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1966){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1967){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1968){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1969){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1970){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1971){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1972){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1973){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1974){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1975){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1976){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1977){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1978){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1979){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1980){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1981){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1982){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1983){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1984){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1985){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1986){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1987){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1988){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1989){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1990){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1991){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1992){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1993){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1994){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1995){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1996){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1997){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1998){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_1999){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2000){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2001){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2002){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2003){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2004){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2005){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2006){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2007){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2008){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2009){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2010){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2011){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2012){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2013){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2014){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2015){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2016){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2017){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2018){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2019){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2020){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2021){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2022){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2023){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2024){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2025){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2026){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2027){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2028){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2029){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2030){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2031){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2032){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2033){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2034){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2035){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2036){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2037){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2038){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2039){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2040){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2041){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2042){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2043){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2044){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2045){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2046){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2047){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2048){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2049){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2050){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2051){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2052){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2053){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2054){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2055){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2056){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2057){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2058){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2059){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2060){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2061){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2062){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2063){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2064){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2065){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2066){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2067){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2068){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2069){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2070){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2071){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2072){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2073){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2074){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2075){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2076){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2077){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2078){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2079){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2080){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2081){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2082){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2083){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2084){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2085){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2086){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2087){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2088){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2089){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2090){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2091){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2092){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2093){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2094){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2095){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2096){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2097){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2098){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2099){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2100){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2101){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2102){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2103){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2104){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2105){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2106){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2107){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2108){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2109){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2110){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2111){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2112){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2113){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2114){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2115){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2116){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2117){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2118){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2119){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2120){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2121){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2122){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2123){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2124){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2125){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2126){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2127){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2128){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2129){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2130){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2131){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2132){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2133){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2134){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2135){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2136){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2137){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2138){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2139){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2140){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2141){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2142){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2143){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2144){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2145){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2146){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2147){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2148){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2149){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2150){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2151){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2152){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2153){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2154){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2155){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2156){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2157){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2158){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2159){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2160){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2161){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2162){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2163){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2164){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2165){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2166){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2167){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2168){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2169){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2170){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2171){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2172){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2173){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2174){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2175){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2176){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2177){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2178){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2179){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2180){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2181){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2182){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2183){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2184){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2185){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2186){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2187){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2188){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2189){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2190){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2191){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2192){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2193){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2194){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2195){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2196){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2197){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2198){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2199){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2200){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2201){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2202){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2203){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2204){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2205){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2206){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2207){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2208){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2209){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2210){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2211){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2212){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2213){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2214){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2215){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2216){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2217){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2218){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2219){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2220){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2221){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2222){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2223){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2224){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2225){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2226){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2227){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2228){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2229){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2230){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2231){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2232){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2233){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2234){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2235){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2236){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2237){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2238){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2239){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2240){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2241){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2242){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2243){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2244){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2245){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2246){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2247){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2248){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2249){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2250){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2251){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2252){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2253){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2254){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2255){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2256){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2257){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2258){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2259){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2260){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2261){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2262){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2263){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2264){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2265){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2266){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2267){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2268){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2269){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2270){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2271){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2272){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2273){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2274){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2275){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2276){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2277){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2278){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2279){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2280){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2281){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2282){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2283){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2284){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2285){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2286){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2287){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2288){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2289){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2290){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2291){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2292){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2293){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2294){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2295){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2296){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2297){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2298){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2299){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2300){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2301){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2302){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2303){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2304){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2305){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2306){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2307){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2308){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2309){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2310){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2311){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2312){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2313){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2314){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2315){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2316){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2317){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2318){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2319){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2320){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2321){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2322){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2323){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2324){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2325){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2326){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2327){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2328){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2329){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2330){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2331){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2332){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2333){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2334){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2335){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2336){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2337){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2338){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2339){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2340){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2341){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2342){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2343){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2344){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2345){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2346){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2347){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2348){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2349){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2350){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2351){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2352){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2353){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2354){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2355){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2356){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2357){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2358){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2359){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2360){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2361){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2362){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2363){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2364){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2365){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2366){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2367){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2368){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2369){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2370){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2371){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2372){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2373){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2374){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2375){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2376){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2377){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2378){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2379){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2380){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2381){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2382){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2383){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2384){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2385){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2386){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2387){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2388){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2389){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2390){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2391){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2392){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2393){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2394){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2395){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2396){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2397){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2398){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2399){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2400){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2401){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2402){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2403){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2404){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2405){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2406){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2407){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2408){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2409){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2410){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2411){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2412){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2413){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2414){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2415){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2416){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2417){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2418){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2419){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2420){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2421){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2422){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2423){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2424){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2425){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2426){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2427){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2428){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2429){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2430){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2431){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2432){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2433){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2434){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2435){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2436){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2437){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2438){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2439){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2440){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2441){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2442){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2443){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2444){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2445){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2446){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2447){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2448){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2449){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2450){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2451){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2452){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2453){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2454){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2455){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2456){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2457){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2458){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2459){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2460){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2461){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2462){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2463){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2464){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2465){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2466){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2467){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2468){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2469){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2470){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2471){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2472){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2473){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2474){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2475){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2476){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2477){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2478){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2479){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2480){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2481){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2482){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2483){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2484){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2485){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2486){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2487){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2488){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2489){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2490){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2491){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2492){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2493){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2494){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2495){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2496){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2497){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2498){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2499){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2500){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2501){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2502){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2503){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2504){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2505){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2506){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2507){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2508){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2509){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2510){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2511){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2512){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2513){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2514){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2515){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2516){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2517){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2518){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2519){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2520){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2521){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2522){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2523){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2524){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2525){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2526){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2527){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2528){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2529){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2530){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2531){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2532){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2533){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2534){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2535){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2536){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2537){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2538){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2539){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2540){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2541){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2542){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2543){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2544){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2545){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2546){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2547){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2548){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2549){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2550){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2551){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2552){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2553){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2554){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2555){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2556){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2557){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2558){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2559){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2560){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2561){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2562){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2563){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2564){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2565){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2566){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2567){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2568){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2569){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2570){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2571){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2572){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2573){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2574){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2575){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2576){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2577){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2578){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2579){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2580){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2581){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2582){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2583){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2584){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2585){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2586){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2587){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2588){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2589){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2590){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2591){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2592){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2593){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2594){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2595){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2596){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2597){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2598){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2599){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2600){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2601){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2602){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2603){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2604){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2605){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2606){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2607){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2608){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2609){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2610){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2611){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2612){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2613){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2614){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2615){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2616){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2617){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2618){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2619){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2620){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2621){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2622){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2623){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2624){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2625){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2626){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2627){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2628){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2629){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2630){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2631){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2632){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2633){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2634){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2635){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2636){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2637){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2638){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2639){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2640){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2641){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2642){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2643){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2644){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2645){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2646){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2647){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2648){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2649){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2650){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2651){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2652){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2653){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2654){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2655){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2656){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2657){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2658){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2659){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2660){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2661){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2662){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2663){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2664){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2665){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2666){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2667){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2668){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2669){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2670){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2671){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2672){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2673){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2674){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2675){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2676){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2677){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2678){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2679){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2680){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2681){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2682){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2683){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2684){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2685){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2686){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2687){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2688){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2689){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2690){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2691){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2692){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2693){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2694){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2695){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2696){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2697){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2698){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2699){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2700){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2701){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2702){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2703){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2704){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2705){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2706){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2707){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2708){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2709){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2710){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2711){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2712){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2713){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2714){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2715){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2716){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2717){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2718){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2719){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2720){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2721){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2722){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2723){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2724){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2725){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2726){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2727){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2728){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2729){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2730){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2731){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2732){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2733){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2734){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2735){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2736){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2737){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2738){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2739){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2740){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2741){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2742){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2743){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2744){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2745){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2746){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2747){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2748){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2749){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2750){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2751){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2752){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2753){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2754){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2755){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2756){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2757){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2758){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2759){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2760){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2761){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2762){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2763){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2764){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2765){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2766){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(0);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2767){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(0);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2768){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2769){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2770){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2771){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2772){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2773){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2774){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2775){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2776){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2777){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2778){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2779){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2780){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2781){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2782){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2783){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2784){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2785){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2786){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2787){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2788){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2789){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2790){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2791){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2792){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2793){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2794){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2795){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2796){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2797){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2798){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2799){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2800){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2801){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2802){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2803){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2804){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2805){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2806){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2807){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2808){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2809){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2810){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2811){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2812){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2813){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2814){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2815){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2816){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2817){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2818){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2819){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2820){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2821){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2822){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2823){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2824){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2825){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2826){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2827){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2828){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2829){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2830){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2831){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2832){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2833){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2834){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2835){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2836){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2837){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2838){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(1);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2839){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(1);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2840){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2841){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2842){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2843){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2844){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2845){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2846){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2847){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2848){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2849){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2850){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2851){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2852){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2853){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2854){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2855){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2856){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2857){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2858){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2859){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2860){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2861){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2862){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2863){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2864){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2865){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2866){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2867){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2868){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2869){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2870){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2871){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2872){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2873){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2874){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2875){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2876){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2877){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2878){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2879){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2880){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2881){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2882){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2883){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2884){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2885){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2886){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2887){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2888){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2889){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2890){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2891){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2892){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2893){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2894){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2895){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2896){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2897){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2898){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2899){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2900){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2901){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2902){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2903){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2904){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2905){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2906){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2907){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2908){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2909){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2910){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(2);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2911){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(2);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2912){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2913){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2914){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2915){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2916){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2917){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2918){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2919){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2920){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2921){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2922){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2923){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2924){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2925){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2926){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2927){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2928){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2929){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2930){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2931){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2932){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2933){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2934){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2935){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2936){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2937){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2938){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2939){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2940){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2941){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2942){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2943){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2944){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2945){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2946){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2947){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2948){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2949){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2950){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2951){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2952){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2953){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2954){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2955){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2956){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2957){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2958){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2959){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2960){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2961){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2962){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2963){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2964){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2965){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2966){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2967){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2968){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2969){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2970){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2971){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2972){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2973){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2974){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2975){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2976){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2977){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2978){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2979){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2980){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2981){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2982){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(3);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2983){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(3);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2984){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2985){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2986){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2987){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2988){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2989){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2990){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2991){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2992){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2993){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2994){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2995){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2996){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2997){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2998){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_2999){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3000){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3001){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3002){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3003){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3004){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3005){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3006){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3007){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3008){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3009){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3010){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3011){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3012){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3013){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3014){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3015){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3016){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3017){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3018){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3019){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3020){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3021){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3022){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3023){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3024){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3025){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3026){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3027){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3028){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3029){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3030){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3031){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3032){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3033){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3034){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3035){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3036){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3037){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3038){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3039){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3040){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3041){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3042){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3043){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3044){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3045){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3046){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3047){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3048){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3049){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3050){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3051){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3052){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3053){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3054){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(5);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3055){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(5);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3056){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3057){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3058){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3059){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3060){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3061){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3062){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3063){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3064){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3065){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3066){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3067){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3068){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3069){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3070){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3071){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3072){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3073){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3074){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3075){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3076){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3077){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3078){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3079){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3080){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3081){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3082){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3083){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3084){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3085){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3086){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3087){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3088){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3089){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3090){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3091){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3092){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3093){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3094){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3095){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3096){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3097){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3098){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3099){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3100){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3101){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3102){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3103){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3104){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3105){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3106){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3107){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3108){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3109){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3110){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3111){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3112){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3113){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3114){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3115){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3116){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3117){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3118){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3119){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3120){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3121){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3122){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3123){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3124){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3125){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3126){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(6);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3127){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(6);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3128){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3129){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(1);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3130){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3131){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(1);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3132){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3133){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(1);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3134){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3135){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(1);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3136){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3137){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(1);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3138){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3139){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(1);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3140){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3141){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(2);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3142){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3143){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(2);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3144){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3145){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(2);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3146){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3147){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(2);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3148){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3149){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(2);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3150){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3151){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(2);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3152){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3153){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(3);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3154){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3155){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(3);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3156){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3157){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(3);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3158){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3159){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(3);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3160){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3161){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(3);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3162){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3163){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(3);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3164){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3165){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(5);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3166){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3167){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(5);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3168){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3169){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(5);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3170){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3171){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(5);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3172){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3173){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(5);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3174){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3175){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(5);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3176){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3177){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(6);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3178){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3179){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(6);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3180){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3181){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(6);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3182){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3183){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(6);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3184){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3185){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(6);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3186){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3187){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(6);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3188){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3189){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(7);
    double ky = k(1);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3190){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3191){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(7);
    double ky = k(2);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3192){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3193){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(7);
    double ky = k(3);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3194){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3195){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(7);
    double ky = k(5);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3196){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3197){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(7);
    double ky = k(6);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3198){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =-0.1;
    double wd = w(7);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }
    TEST(grating_3199){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double C =2.2;
    double wd = w(7);
    double kx = k(7);
    double ky = k(7);

    Grating S(&integrator, {kx, ky}, wd, C);
    //Spatiotemporal signal
    S.computeSpatiotemporal();
    g.set_real(S.spatioTemporal());
    //fourier signal

    S.computeFourierTransform();
    f = S.fourierTransform();
    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-10);
          }
       }
    }
    }






}


