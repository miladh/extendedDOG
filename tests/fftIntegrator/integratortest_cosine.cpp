#include <unittest++/UnitTest++.h>
#include <armadillo>
#include <iostream>

#include "integrator.h"

using namespace std;
using namespace arma;



SUITE(INTEGRATOR){

    TEST(cosine_0){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_2){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_3){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_4){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_5){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_6){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_7){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_8){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_9){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_10){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_11){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_12){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_13){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_14){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_15){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_16){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_17){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_18){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_19){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_20){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_21){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_22){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_23){
    int ns = 2;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_24){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_25){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_26){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_27){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_28){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_29){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_30){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_31){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_32){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_33){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_34){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_35){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_36){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_37){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_38){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_39){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_40){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_41){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_42){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_43){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_44){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_45){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_46){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_47){
    int ns = 2;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_48){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_49){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_50){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_51){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_52){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_53){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_54){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_55){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_56){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_57){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_58){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_59){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_60){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_61){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_62){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_63){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_64){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_65){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_66){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_67){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_68){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_69){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_70){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_71){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_72){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_73){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_74){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_75){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_76){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_77){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_78){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_79){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_80){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_81){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_82){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_83){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_84){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_85){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_86){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_87){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_88){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_89){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_90){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_91){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_92){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_93){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_94){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_95){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_96){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_97){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_98){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_99){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_100){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_101){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_102){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_103){
    int ns = 2;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_104){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_105){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_106){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_107){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_108){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_109){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_110){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_111){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_112){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_113){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_114){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_115){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_116){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_117){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_118){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_119){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_120){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_121){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_122){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_123){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_124){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_125){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_126){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_127){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_128){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_129){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_130){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_131){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_132){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_133){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_134){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_135){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_136){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_137){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_138){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_139){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_140){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_141){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_142){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_143){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_144){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_145){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_146){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_147){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_148){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_149){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_150){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_151){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_152){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_153){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_154){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_155){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_156){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_157){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_158){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_159){
    int ns = 2;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_160){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_161){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_162){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_163){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_164){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_165){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_166){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_167){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_168){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_169){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_170){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_171){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_172){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_173){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_174){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_175){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_176){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_177){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_178){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_179){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_180){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_181){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_182){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_183){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_184){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_185){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_186){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_187){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_188){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_189){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_190){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_191){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_192){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_193){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_194){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_195){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_196){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_197){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_198){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_199){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_200){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_201){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_202){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_203){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_204){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_205){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_206){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_207){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_208){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_209){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_210){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_211){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_212){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_213){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_214){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_215){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_216){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_217){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_218){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_219){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_220){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_221){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_222){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_223){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_224){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_225){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_226){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_227){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_228){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_229){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_230){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_231){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_232){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_233){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_234){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_235){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_236){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_237){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_238){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_239){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_240){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_241){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_242){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_243){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_244){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_245){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_246){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_247){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_248){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_249){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_250){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_251){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_252){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_253){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_254){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_255){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_256){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_257){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_258){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_259){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_260){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_261){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_262){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_263){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_264){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_265){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_266){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_267){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_268){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_269){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_270){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_271){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_272){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_273){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_274){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_275){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_276){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_277){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_278){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_279){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_280){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_281){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_282){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_283){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_284){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_285){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_286){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_287){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_288){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_289){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_290){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_291){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_292){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_293){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_294){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_295){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_296){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_297){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_298){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_299){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_300){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_301){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_302){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_303){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_304){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_305){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_306){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_307){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_308){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_309){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_310){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_311){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_312){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_313){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_314){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_315){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_316){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_317){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_318){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_319){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_320){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_321){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_322){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_323){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_324){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_325){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_326){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_327){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_328){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_329){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_330){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_331){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_332){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_333){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_334){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_335){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_336){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_337){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_338){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_339){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_340){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_341){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_342){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_343){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_344){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_345){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_346){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_347){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_348){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_349){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_350){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_351){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_352){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_353){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_354){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_355){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_356){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_357){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_358){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_359){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_360){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_361){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_362){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_363){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_364){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_365){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_366){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_367){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_368){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_369){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_370){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_371){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_372){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_373){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_374){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_375){
    int ns = 3;
    int nt = 2;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_376){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_377){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_378){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_379){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_380){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_381){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_382){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_383){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_384){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_385){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_386){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_387){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_388){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_389){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_390){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_391){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_392){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_393){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_394){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_395){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_396){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_397){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_398){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_399){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_400){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_401){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_402){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_403){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_404){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_405){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_406){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_407){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_408){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_409){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_410){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_411){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_412){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_413){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_414){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_415){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_416){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_417){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_418){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_419){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_420){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_421){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_422){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_423){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_424){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_425){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_426){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_427){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_428){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_429){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_430){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_431){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_432){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_433){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_434){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_435){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_436){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_437){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_438){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_439){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_440){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_441){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_442){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_443){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_444){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_445){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_446){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_447){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_448){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_449){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_450){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_451){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_452){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_453){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_454){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_455){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_456){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_457){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_458){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_459){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_460){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_461){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_462){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_463){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_464){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_465){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_466){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_467){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_468){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_469){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_470){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_471){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_472){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_473){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_474){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_475){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_476){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_477){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_478){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_479){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_480){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_481){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_482){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_483){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_484){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_485){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_486){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_487){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_488){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_489){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_490){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_491){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_492){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_493){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_494){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_495){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_496){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_497){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_498){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_499){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_500){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_501){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_502){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_503){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_504){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_505){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_506){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_507){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_508){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_509){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_510){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_511){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_512){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_513){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_514){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_515){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_516){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_517){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_518){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_519){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_520){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_521){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_522){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_523){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_524){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_525){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_526){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_527){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_528){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_529){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_530){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_531){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_532){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_533){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_534){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_535){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_536){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_537){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_538){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_539){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_540){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_541){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_542){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_543){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_544){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_545){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_546){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_547){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_548){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_549){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_550){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_551){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_552){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_553){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_554){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_555){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_556){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_557){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_558){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_559){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_560){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_561){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_562){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_563){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_564){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_565){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_566){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_567){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_568){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_569){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_570){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_571){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_572){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_573){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_574){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_575){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_576){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_577){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_578){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_579){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_580){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_581){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_582){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_583){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_584){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_585){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_586){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_587){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_588){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_589){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_590){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_591){
    int ns = 3;
    int nt = 2;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_592){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_593){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_594){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_595){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_596){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_597){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_598){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_599){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_600){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_601){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_602){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_603){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_604){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_605){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_606){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_607){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_608){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_609){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_610){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_611){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_612){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_613){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_614){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_615){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_616){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_617){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_618){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_619){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_620){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_621){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_622){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_623){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_624){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_625){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_626){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_627){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_628){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_629){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_630){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_631){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_632){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_633){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_634){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_635){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_636){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_637){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_638){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_639){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_640){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_641){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_642){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_643){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_644){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_645){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_646){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_647){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_648){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_649){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_650){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_651){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_652){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_653){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_654){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_655){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_656){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_657){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_658){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_659){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_660){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_661){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_662){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_663){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_664){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_665){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_666){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_667){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_668){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_669){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_670){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_671){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_672){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_673){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_674){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_675){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_676){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_677){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_678){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_679){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_680){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_681){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_682){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_683){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_684){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_685){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_686){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_687){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_688){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_689){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_690){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_691){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_692){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_693){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_694){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_695){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_696){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_697){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_698){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_699){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_700){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_701){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_702){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_703){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_704){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_705){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_706){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_707){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_708){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_709){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_710){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_711){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_712){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_713){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_714){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_715){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_716){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_717){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_718){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_719){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_720){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_721){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_722){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_723){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_724){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_725){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_726){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_727){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_728){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_729){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_730){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_731){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_732){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_733){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_734){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_735){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_736){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_737){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_738){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_739){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_740){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_741){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_742){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_743){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_744){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_745){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_746){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_747){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_748){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_749){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_750){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_751){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_752){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_753){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_754){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_755){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_756){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_757){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_758){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_759){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_760){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_761){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_762){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_763){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_764){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_765){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_766){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_767){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_768){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_769){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_770){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_771){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_772){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_773){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_774){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_775){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_776){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_777){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_778){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_779){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_780){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_781){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_782){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_783){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_784){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_785){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_786){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_787){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_788){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_789){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_790){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_791){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_792){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_793){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_794){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_795){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_796){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_797){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_798){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_799){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_800){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_801){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_802){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_803){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_804){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_805){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_806){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_807){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_808){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_809){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_810){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_811){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_812){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_813){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_814){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_815){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_816){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_817){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_818){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_819){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_820){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_821){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_822){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_823){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_824){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_825){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_826){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_827){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_828){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_829){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_830){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_831){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_832){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_833){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_834){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_835){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_836){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_837){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_838){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_839){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_840){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_841){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_842){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_843){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_844){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_845){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_846){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_847){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_848){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_849){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_850){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_851){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_852){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_853){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_854){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_855){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_856){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_857){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_858){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_859){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_860){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_861){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_862){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_863){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_864){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_865){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_866){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_867){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_868){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_869){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_870){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_871){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_872){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_873){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_874){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_875){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_876){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_877){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_878){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_879){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_880){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_881){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_882){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_883){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_884){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_885){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_886){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_887){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_888){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_889){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_890){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_891){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_892){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_893){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_894){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_895){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_896){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_897){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_898){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_899){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_900){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_901){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_902){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_903){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_904){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_905){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_906){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_907){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_908){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_909){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_910){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_911){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_912){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_913){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_914){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_915){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_916){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_917){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_918){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_919){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_920){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_921){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_922){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_923){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_924){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_925){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_926){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_927){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_928){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_929){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_930){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_931){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_932){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_933){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_934){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_935){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_936){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_937){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_938){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_939){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_940){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_941){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_942){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_943){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_944){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_945){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_946){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_947){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_948){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_949){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_950){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_951){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_952){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_953){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_954){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_955){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_956){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_957){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_958){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_959){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_960){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_961){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_962){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_963){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_964){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_965){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_966){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_967){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_968){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_969){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_970){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_971){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_972){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_973){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_974){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_975){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_976){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_977){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_978){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_979){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_980){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_981){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_982){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_983){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_984){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_985){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_986){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_987){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_988){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_989){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_990){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_991){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_992){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_993){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_994){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_995){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_996){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_997){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_998){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_999){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1000){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1001){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1002){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1003){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1004){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1005){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1006){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1007){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1008){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1009){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1010){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1011){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1012){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1013){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1014){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1015){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1016){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1017){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1018){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1019){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1020){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1021){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1022){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1023){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1024){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1025){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1026){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1027){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1028){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1029){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1030){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1031){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1032){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1033){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1034){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1035){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1036){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1037){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1038){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1039){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1040){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1041){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1042){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1043){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1044){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1045){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1046){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1047){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1048){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1049){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1050){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1051){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1052){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1053){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1054){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1055){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1056){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1057){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1058){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1059){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1060){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1061){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1062){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1063){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1064){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1065){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1066){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1067){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1068){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1069){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1070){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1071){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1072){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1073){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1074){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1075){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1076){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1077){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1078){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1079){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1080){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1081){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1082){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1083){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1084){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1085){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1086){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1087){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1088){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1089){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1090){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1091){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1092){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1093){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1094){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1095){
    int ns = 3;
    int nt = 3;
    double ds = 0.01;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1096){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1097){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1098){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1099){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1100){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1101){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1102){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1103){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1104){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1105){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1106){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1107){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1108){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1109){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1110){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1111){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1112){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1113){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1114){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1115){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1116){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1117){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1118){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1119){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1120){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1121){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1122){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1123){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1124){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1125){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1126){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1127){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1128){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1129){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1130){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1131){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1132){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1133){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1134){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1135){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1136){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1137){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1138){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1139){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1140){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1141){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1142){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1143){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1144){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1145){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1146){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1147){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1148){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1149){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1150){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1151){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1152){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1153){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1154){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1155){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1156){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1157){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1158){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1159){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1160){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1161){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1162){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1163){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1164){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1165){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1166){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1167){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1168){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1169){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1170){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1171){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1172){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1173){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1174){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1175){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1176){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1177){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1178){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1179){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1180){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1181){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1182){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1183){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1184){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1185){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1186){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1187){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1188){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1189){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1190){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1191){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1192){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1193){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1194){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1195){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1196){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1197){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1198){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1199){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1200){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1201){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1202){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1203){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1204){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1205){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1206){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1207){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1208){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1209){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1210){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1211){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1212){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1213){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1214){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1215){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1216){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1217){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1218){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1219){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1220){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1221){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1222){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1223){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1224){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1225){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1226){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1227){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1228){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1229){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1230){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1231){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1232){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1233){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1234){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1235){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1236){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1237){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1238){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1239){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1240){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1241){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1242){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1243){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1244){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1245){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1246){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1247){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1248){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1249){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1250){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1251){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1252){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1253){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1254){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1255){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1256){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1257){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1258){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1259){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1260){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1261){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1262){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1263){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1264){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1265){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1266){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1267){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1268){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1269){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1270){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1271){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1272){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1273){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1274){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1275){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1276){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1277){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1278){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1279){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1280){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1281){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1282){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1283){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1284){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1285){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1286){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1287){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1288){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1289){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1290){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1291){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1292){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1293){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1294){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1295){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1296){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1297){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1298){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1299){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1300){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1301){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1302){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1303){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1304){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1305){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1306){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1307){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1308){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1309){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1310){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1311){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1312){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1313){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1314){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1315){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1316){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1317){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1318){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1319){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1320){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1321){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1322){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1323){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1324){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1325){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1326){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1327){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1328){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1329){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1330){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1331){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1332){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1333){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1334){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1335){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1336){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1337){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1338){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1339){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1340){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1341){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1342){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1343){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1344){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1345){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1346){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1347){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.01;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1348){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1349){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1350){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1351){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1352){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1353){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1354){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1355){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1356){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1357){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1358){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1359){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1360){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1361){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1362){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1363){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1364){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1365){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1366){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1367){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1368){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1369){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1370){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1371){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1372){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1373){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1374){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1375){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1376){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1377){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1378){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1379){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1380){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1381){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1382){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1383){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(0);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1384){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1385){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1386){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1387){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1388){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1389){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1390){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1391){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1392){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1393){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1394){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1395){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1396){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1397){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1398){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1399){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1400){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1401){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1402){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1403){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1404){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1405){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1406){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1407){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1408){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1409){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1410){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1411){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1412){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1413){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1414){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1415){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1416){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1417){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1418){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1419){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(1);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1420){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1421){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1422){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1423){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1424){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1425){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1426){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1427){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1428){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1429){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1430){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1431){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1432){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1433){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1434){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1435){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1436){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1437){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1438){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1439){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1440){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1441){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1442){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1443){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1444){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1445){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1446){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1447){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1448){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1449){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1450){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1451){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1452){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1453){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1454){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1455){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(2);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1456){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1457){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1458){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1459){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1460){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1461){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1462){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1463){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1464){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1465){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1466){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1467){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1468){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1469){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1470){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1471){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1472){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1473){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1474){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1475){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1476){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1477){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1478){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1479){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1480){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1481){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1482){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1483){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1484){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1485){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1486){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1487){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1488){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1489){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1490){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1491){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(3);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1492){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1493){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1494){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1495){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1496){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1497){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1498){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1499){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1500){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1501){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1502){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1503){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1504){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1505){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1506){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1507){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1508){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1509){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1510){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1511){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1512){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1513){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1514){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1515){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1516){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1517){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1518){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1519){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1520){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1521){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1522){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1523){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1524){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1525){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1526){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1527){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(5);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1528){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1529){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1530){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1531){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1532){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1533){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1534){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1535){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1536){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1537){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1538){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1539){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1540){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1541){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1542){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1543){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1544){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1545){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1546){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1547){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1548){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1549){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1550){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1551){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1552){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1553){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1554){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1555){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1556){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1557){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1558){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1559){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1560){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1561){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1562){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1563){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(6);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1564){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(1);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1565){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(1);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1566){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(1);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1567){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(1);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1568){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(1);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1569){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(1);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1570){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(2);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1571){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(2);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1572){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(2);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1573){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(2);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1574){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(2);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1575){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(2);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1576){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(3);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1577){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(3);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1578){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(3);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1579){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(3);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1580){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(3);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1581){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(3);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1582){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(5);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1583){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(5);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1584){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(5);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1585){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(5);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1586){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(5);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1587){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(5);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1588){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(6);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1589){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(6);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1590){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(6);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1591){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(6);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1592){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(6);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1593){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(6);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1594){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(7);
    double ky = k(1);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1595){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(7);
    double ky = k(2);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1596){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(7);
    double ky = k(3);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1597){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(7);
    double ky = k(5);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1598){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(7);
    double ky = k(6);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
    TEST(cosine_1599){
    int ns = 3;
    int nt = 3;
    double ds = 0.5;
    double dt = 0.5;

    int Ns = pow(2,ns);
    int Nt = pow(2,nt);

    Integrator integrator(nt, dt, ns, ds);

    vec s = integrator.coordinateVec();
    vec k = integrator.spatialFreqVec();
    vec t = integrator.timeVec();
    vec w = integrator.temporalFreqVec();

    cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
    cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

    double wd = w(7);
    double kx = k(7);
    double ky = k(7);

    //Spatiotemporal signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
        }
      }
    }

    //fourier signal
    for(int l = 0; l < Nt; l++){
      for(int i = 0; i < Ns; i++){
        for(int j = 0; j < Ns; j++){
          f(i,j,l) = Functions::delta(k[i], kx)
                   * Functions::delta(k[j], ky)
                   * Functions::delta(w[l], -wd);
        }
      }
    }

    f *= 8*PI*PI*PI;
    f /= integrator.spatialFreqResolution()
    * integrator.spatialFreqResolution()
    * integrator.temporalFreqResolution();

    // Backward
    G = integrator.backwardFFT(f);


    // Test
    for(int l = 0; l < Nt; l++){
       for(int i = 0; i < Ns; i++){
          for(int j = 0; j < Ns; j++){
               CHECK_CLOSE(real(g(i,j,l)),
                           real(G(i,j,l)), 1e-9);
          }
       }
    }
    }
}



