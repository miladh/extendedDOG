#include <unittest++/UnitTest++.h>
#include <armadillo>
#include <iostream>

#include "integrator.h"

using namespace std;
using namespace arma;



SUITE(INTEGRATOR){

    TEST(cosine_0){
        int ns = 2;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_1){
        int ns = 2;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_2){
        int ns = 2;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_3){
        int ns = 2;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_4){
        int ns = 2;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_5){
        int ns = 2;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_6){
        int ns = 2;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_7){
        int ns = 2;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_8){
        int ns = 2;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_9){
        int ns = 2;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_10){
        int ns = 2;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_11){
        int ns = 2;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_12){
        int ns = 2;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_13){
        int ns = 2;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_14){
        int ns = 2;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_15){
        int ns = 2;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_16){
        int ns = 2;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_17){
        int ns = 2;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_18){
        int ns = 2;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_19){
        int ns = 2;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_20){
        int ns = 2;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_21){
        int ns = 2;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_22){
        int ns = 2;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_23){
        int ns = 2;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_24){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_25){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_26){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_27){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_28){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_29){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_30){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_31){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_32){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_33){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_34){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_35){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_36){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_37){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_38){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_39){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_40){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_41){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_42){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_43){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_44){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_45){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_46){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_47){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_48){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_49){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_50){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_51){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_52){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_53){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_54){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_55){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_56){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_57){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_58){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_59){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_60){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_61){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_62){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_63){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_64){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_65){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_66){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_67){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_68){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_69){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_70){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_71){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_72){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_73){
        int ns = 3;
        int nt = 2;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_74){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_75){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_76){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_77){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_78){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_79){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_80){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_81){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_82){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_83){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_84){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_85){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_86){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_87){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_88){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_89){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_90){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_91){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_92){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_93){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_94){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_95){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_96){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_97){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_98){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_99){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_100){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_101){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_102){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_103){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_104){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_105){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_106){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_107){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_108){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_109){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_110){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_111){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_112){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_113){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_114){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_115){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_116){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_117){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_118){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_119){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_120){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_121){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_122){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_123){
        int ns = 3;
        int nt = 2;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_124){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_125){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_126){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_127){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_128){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_129){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_130){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_131){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_132){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_133){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_134){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_135){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_136){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_137){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_138){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_139){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_140){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_141){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_142){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_143){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_144){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_145){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_146){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_147){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_148){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_149){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_150){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(1);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_151){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(1);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_152){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(1);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_153){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(1);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_154){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(2);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_155){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(2);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_156){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(2);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_157){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(2);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_158){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(2);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_159){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(3);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_160){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(3);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_161){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(3);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_162){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(3);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_163){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(3);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_164){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(4);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_165){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(4);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_166){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(4);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_167){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(4);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_168){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(4);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_169){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(5);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_170){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(5);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_171){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(5);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_172){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(5);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_173){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(5);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_174){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_175){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(1);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_176){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(1);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_177){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(1);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_178){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(1);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_179){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(2);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_180){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(2);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_181){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(2);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_182){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(2);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_183){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(2);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_184){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(3);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_185){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(3);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_186){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(3);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_187){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(3);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_188){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(3);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_189){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(4);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_190){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(4);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_191){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(4);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_192){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(4);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_193){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(4);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_194){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(5);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_195){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(5);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_196){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(5);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_197){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(5);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_198){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(5);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_199){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_200){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(1);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_201){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(1);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_202){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(1);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_203){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(1);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_204){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(2);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_205){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(2);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_206){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(2);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_207){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(2);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_208){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(2);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_209){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(3);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_210){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(3);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_211){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(3);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_212){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(3);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_213){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(3);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_214){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(4);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_215){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(4);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_216){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(4);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_217){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(4);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_218){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(4);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_219){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(5);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_220){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(5);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_221){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(5);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_222){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(5);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_223){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(5);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_224){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_225){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(1);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_226){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(1);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_227){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(1);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_228){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(1);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_229){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(2);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_230){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(2);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_231){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(2);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_232){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(2);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_233){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(2);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_234){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(3);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_235){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(3);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_236){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(3);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_237){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(3);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_238){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(3);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_239){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(4);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_240){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(4);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_241){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(4);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_242){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(4);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_243){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(4);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_244){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(5);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_245){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(5);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_246){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(5);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_247){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(5);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_248){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(5);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_249){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_250){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_251){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_252){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_253){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_254){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_255){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_256){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_257){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_258){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_259){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_260){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_261){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_262){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_263){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_264){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_265){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_266){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_267){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_268){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_269){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_270){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_271){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_272){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_273){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_274){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_275){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(1);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_276){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(1);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_277){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(1);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_278){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(1);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_279){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(2);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_280){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(2);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_281){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(2);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_282){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(2);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_283){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(2);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_284){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(3);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_285){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(3);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_286){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(3);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_287){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(3);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_288){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(3);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_289){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(4);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_290){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(4);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_291){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(4);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_292){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(4);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_293){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(4);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_294){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(5);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_295){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(5);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_296){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(5);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_297){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(5);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_298){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(5);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_299){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_300){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(1);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_301){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(1);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_302){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(1);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_303){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(1);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_304){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(2);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_305){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(2);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_306){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(2);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_307){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(2);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_308){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(2);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_309){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(3);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_310){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(3);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_311){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(3);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_312){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(3);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_313){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(3);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_314){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(4);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_315){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(4);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_316){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(4);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_317){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(4);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_318){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(4);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_319){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(5);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_320){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(5);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_321){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(5);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_322){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(5);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_323){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(5);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_324){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_325){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(1);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_326){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(1);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_327){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(1);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_328){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(1);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_329){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(2);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_330){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(2);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_331){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(2);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_332){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(2);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_333){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(2);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_334){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(3);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_335){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(3);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_336){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(3);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_337){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(3);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_338){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(3);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_339){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(4);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_340){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(4);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_341){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(4);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_342){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(4);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_343){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(4);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_344){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(5);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_345){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(5);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_346){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(5);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_347){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(5);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_348){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(5);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_349){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_350){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(1);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_351){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(1);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_352){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(1);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_353){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(1);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_354){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(2);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_355){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(2);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_356){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(2);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_357){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(2);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_358){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(2);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_359){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(3);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_360){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(3);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_361){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(3);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_362){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(3);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_363){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(3);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_364){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(4);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_365){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(4);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_366){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(4);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_367){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(4);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_368){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(4);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_369){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(5);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_370){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(5);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_371){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(5);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_372){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(5);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_373){
        int ns = 3;
        int nt = 3;
        double ds = 0.01;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(5);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_374){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_375){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_376){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_377){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_378){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_379){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_380){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_381){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_382){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_383){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_384){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_385){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_386){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_387){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_388){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_389){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_390){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_391){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_392){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_393){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_394){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_395){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_396){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_397){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_398){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_399){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_400){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(1);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_401){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(1);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_402){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(1);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_403){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(1);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_404){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(2);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_405){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(2);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_406){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(2);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_407){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(2);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_408){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(2);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_409){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(3);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_410){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(3);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_411){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(3);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_412){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(3);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_413){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(3);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_414){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(4);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_415){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(4);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_416){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(4);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_417){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(4);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_418){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(4);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_419){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(5);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_420){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(5);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_421){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(5);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_422){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(5);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_423){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(5);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_424){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_425){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(1);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_426){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(1);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_427){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(1);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_428){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(1);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_429){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(2);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_430){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(2);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_431){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(2);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_432){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(2);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_433){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(2);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_434){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(3);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_435){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(3);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_436){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(3);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_437){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(3);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_438){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(3);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_439){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(4);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_440){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(4);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_441){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(4);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_442){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(4);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_443){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(4);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_444){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(5);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_445){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(5);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_446){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(5);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_447){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(5);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_448){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(5);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_449){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_450){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(1);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_451){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(1);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_452){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(1);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_453){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(1);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_454){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(2);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_455){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(2);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_456){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(2);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_457){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(2);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_458){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(2);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_459){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(3);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_460){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(3);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_461){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(3);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_462){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(3);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_463){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(3);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_464){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(4);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_465){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(4);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_466){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(4);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_467){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(4);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_468){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(4);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_469){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(5);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_470){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(5);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_471){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(5);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_472){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(5);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_473){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(5);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_474){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_475){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(1);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_476){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(1);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_477){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(1);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_478){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(1);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_479){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(2);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_480){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(2);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_481){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(2);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_482){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(2);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_483){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(2);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_484){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(3);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_485){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(3);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_486){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(3);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_487){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(3);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_488){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(3);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_489){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(4);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_490){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(4);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_491){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(4);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_492){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(4);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_493){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(4);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_494){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(5);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_495){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(5);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_496){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(5);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_497){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(5);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_498){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.01;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(5);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_499){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_500){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_501){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_502){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_503){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(1);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_504){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_505){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_506){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_507){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_508){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(2);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_509){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_510){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_511){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_512){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_513){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(3);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_514){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_515){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_516){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_517){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_518){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(4);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_519){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_520){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_521){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_522){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_523){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(1);
        double kx = k(5);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_524){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_525){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(1);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_526){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(1);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_527){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(1);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_528){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(1);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_529){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(2);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_530){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(2);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_531){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(2);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_532){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(2);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_533){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(2);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_534){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(3);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_535){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(3);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_536){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(3);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_537){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(3);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_538){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(3);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_539){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(4);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_540){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(4);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_541){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(4);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_542){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(4);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_543){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(4);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_544){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(5);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_545){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(5);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_546){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(5);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_547){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(5);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_548){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(2);
        double kx = k(5);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_549){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_550){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(1);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_551){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(1);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_552){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(1);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_553){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(1);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_554){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(2);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_555){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(2);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_556){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(2);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_557){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(2);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_558){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(2);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_559){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(3);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_560){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(3);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_561){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(3);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_562){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(3);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_563){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(3);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_564){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(4);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_565){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(4);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_566){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(4);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_567){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(4);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_568){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(4);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_569){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(5);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_570){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(5);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_571){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(5);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_572){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(5);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_573){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(3);
        double kx = k(5);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_574){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_575){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(1);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_576){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(1);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_577){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(1);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_578){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(1);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_579){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(2);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_580){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(2);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_581){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(2);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_582){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(2);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_583){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(2);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_584){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(3);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_585){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(3);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_586){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(3);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_587){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(3);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_588){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(3);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_589){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(4);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_590){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(4);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_591){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(4);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_592){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(4);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_593){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(4);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_594){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(5);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_595){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(5);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_596){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(5);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_597){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(5);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_598){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(4);
        double kx = k(5);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_599){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(1);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_600){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(1);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_601){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(1);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_602){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(1);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_603){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(1);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_604){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(2);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_605){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(2);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_606){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(2);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_607){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(2);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_608){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(2);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_609){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(3);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_610){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(3);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_611){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(3);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_612){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(3);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_613){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(3);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_614){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(4);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_615){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(4);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_616){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(4);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_617){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(4);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_618){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(4);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_619){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(5);
        double ky = k(1);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_620){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(5);
        double ky = k(2);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_621){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(5);
        double ky = k(3);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_622){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(5);
        double ky = k(4);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
    TEST(cosine_623){
        int ns = 3;
        int nt = 3;
        double ds = 0.5;
        double dt = 0.5;

        int Ns = pow(2,ns);
        int Nt = pow(2,nt);

        Integrator integrator(nt, dt, ns, ds);

        vec s = integrator.coordinateVec();
        vec k = integrator.spatialFreqVec();
        vec t = integrator.timeVec();
        vec w = integrator.temporalFreqVec();

        cx_cube g = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube G = zeros<cx_cube>(Ns, Ns, Nt);
        cx_cube f = zeros<cx_cube>(Ns, Ns, Nt);

        double wd = w(5);
        double kx = k(5);
        double ky = k(5);

        //Spatiotemporal signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    g(i,j,l) =cos(kx*s[i] + ky*s[j] - wd * t[l]);
                }
            }
        }

        //fourier signal
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    f(i,j,l) = Functions::delta(k[i], kx)
                            * Functions::delta(k[j], ky)
                            * Functions::delta(w[l], -wd);
                }
            }
        }

        f *= 8*PI*PI*PI;
        f /= integrator.spatialFreqResolution()
                * integrator.spatialFreqResolution()
                * integrator.temporalFreqResolution();

        // Backward
        G = integrator.integrate(f);
        G = FFTHelper::fftShift(G);

        // Test
        for(int l = 0; l < Nt; l++){
            for(int i = 0; i < Ns; i++){
                for(int j = 0; j < Ns; j++){
                    CHECK_CLOSE(real(g(i,j,l)),
                                real(G(i,j,l)), 1e-9);
                }
            }
        }
    }
}



